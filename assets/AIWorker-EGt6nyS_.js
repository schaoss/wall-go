var K=Object.defineProperty;var F=(E,B,R)=>B in E?K(E,B,{enumerable:!0,configurable:!0,writable:!0,value:R}):E[B]=R;var $=(E,B,R)=>F(E,typeof B!="symbol"?B+"":B,R);(function(){"use strict";function B(c,t,e,n=2){const r=[[c,0]],o=new Set([`${c.x},${c.y}`]);for(;r.length;){const[{x:s,y:i},l]=r.shift();if(l>n)continue;if(s===t.x&&i===t.y&&l!==0)return!0;if(l===n)continue;[[1,0,"left"],[-1,0,"left"],[0,1,"top"],[0,-1,"top"]].forEach(([a,u,f])=>{const g=s+a,p=i+u;if(g<0||p<0||g>=7||p>=7||(f==="left"?a===1?e[i][s+1].wallLeft:e[i][s].wallLeft:u===1?e[i+1][s].wallTop:e[i][s].wallTop)||e[p][g].stone)return;const x=`${g},${p}`;o.has(x)||(o.add(x),r.push([{x:g,y:p},l+1]))})}return!1}function R(c,t,e){const n=e.x-t.x,r=e.y-t.y;return n===1&&r===0?!!c[e.y][e.x].wallLeft:n===-1&&r===0?!!c[t.y][t.x].wallLeft:n===0&&r===1?!!c[e.y][e.x].wallTop:n===0&&r===-1?!!c[t.y][t.x].wallTop:!0}function L(c,t,e){const n=[],r=c.length,o=["top","left","right","bottom"];for(const s of o){let i=!1;s==="top"&&e>0&&!c[e][t].wallTop&&(i=!0),s==="left"&&t>0&&!c[e][t].wallLeft&&(i=!0),s==="right"&&t<r-1&&!c[e][t+1].wallLeft&&(i=!0),s==="bottom"&&e<r-1&&!c[e+1][t].wallTop&&(i=!0),i&&n.push({type:"wall",from:{x:t,y:e},pos:{x:t,y:e},dir:s})}return n}function k(c){const t=c.length,e=Array.from({length:t},()=>Array(t).fill(!1)),n=Array.from({length:t},()=>Array(t).fill(null)),r=[[1,0,"left"],[-1,0,"left"],[0,1,"top"],[0,-1,"top"]];function o(s,i){const l=[{x:s,y:i}],y=[],a=new Set;for(e[i][s]=!0;l.length;){const{x:u,y:f}=l.shift();y.push({x:u,y:f});const g=c[f][u];g.stone&&a.add(g.stone),r.forEach(([p,d,x])=>{const m=u+p,h=f+d;m<0||h<0||m>=t||h>=t||(x==="left"?p===1?c[f][u+1].wallLeft:g.wallLeft:d===1?c[h][m].wallTop:g.wallTop)||e[h][m]||(e[h][m]=!0,l.push({x:m,y:h}))})}if(a.size===1){const u=a.values().next().value;y.forEach(({x:f,y:g})=>{n[g][f]=u})}}for(let s=0;s<t;s++)for(let i=0;i<t;i++)e[s][i]||o(i,s);return n}function b({legalActions:c}){return c.length===0?null:c[Math.floor(Math.random()*c.length)]}function _(c,t){const{board:e}=c,n=[];for(let r=0;r<e.length;r++)for(let o=0;o<e.length;o++)B(t,{x:o,y:r},e)&&n.push({x:o,y:r});return n}function O(c){const{board:t,turn:e,phase:n}=c,r=[];if(n==="placing")for(let o=0;o<t.length;o++)for(let s=0;s<t.length;s++)t[o][s].stone||r.push({type:"place",pos:{x:s,y:o}});else if(n==="playing")for(let o=0;o<t.length;o++)for(let s=0;s<t.length;s++)t[o][s].stone===e&&(_(c,{x:s,y:o}).forEach(i=>{for(const l of L(t,i.x,i.y))r.push({type:"move",from:{x:s,y:o},pos:{x:i.x,y:i.y},followUp:l})}),r.push(...L(t,s,o)));return r}function M(c){return JSON.parse(JSON.stringify(c))}function v(c,t){const e=M(c),{board:n,turn:r}=e;if(t.type==="place")n[t.pos.y][t.pos.x].stone=r;else if(t.type==="move"&&t.from){if(n[t.from.y][t.from.x].stone=null,n[t.pos.y][t.pos.x].stone=r,t.followUp)return v(e,t.followUp)}else t.type==="wall"&&t.dir&&(t.dir==="top"&&(n[t.pos.y][t.pos.x].wallTop=r),t.dir==="left"&&(n[t.pos.y][t.pos.x].wallLeft=r),t.dir==="right"&&(n[t.pos.y][t.pos.x+1].wallLeft=r),t.dir==="bottom"&&(n[t.pos.y+1][t.pos.x].wallTop=r));return e.turn=r==="R"?"B":"R",e}function P(c,t){const e=t.filter(l=>l.type==="place");if(e.length===1)return e[0];const n=c.board.length;function r(l,y){var d,x;const{board:a}=l,u=[];for(let m=0;m<n;m++)for(let h=0;h<n;h++)a[m][h].stone===y&&u.push({x:h,y:m});const f=Array.from({length:n},()=>Array(n).fill(!1)),g=[...u];let p=0;for(;g.length;){const{x:m,y:h}=g.shift();if(f[h][m])continue;f[h][m]=!0,p++;const w=[{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];for(const{dx:A,dy:D}of w){const S=m+A,I=h+D;S>=0&&S<n&&I>=0&&I<n&&!f[I][S]&&!a[I][S].stone&&(A===1&&!a[h][m+1].wallLeft||A===-1&&!a[h][m].wallLeft||D===1&&!((x=(d=a[h+1])==null?void 0:d[m])!=null&&x.wallTop)||D===-1&&!a[h][m].wallTop)&&g.push({x:S,y:I})}}return p}function o(l){const{x:y,y:a}=l;return(y===0||y===n-1)&&(a===0||a===n-1)?-3:y===0||y===n-1||a===0||a===n-1?-2:0}let s=-1/0,i=[];for(const l of e){const y=v(c,l),a=r(y,c.turn)+o(l.pos);a>s?(s=a,i=[l]):a===s&&i.push(l)}return b({legalActions:i})}function C(c,t){const e=Object.fromEntries(t.map(o=>[o,0])),n=new Set;if(c.forEach((o,s)=>o.forEach((i,l)=>{i.stone&&n.add(`${l},${s}`)})),n.size===0)return{finished:!1,score:e};const r=k(c);for(let o=0;o<c.length;o++)for(let s=0;s<c.length;s++){const i=r[o][s];i&&(e[i]++,n.delete(`${s},${o}`))}if(n.size===0){const[o,s]=t;return e[o]>e[s]?{finished:!0,winner:o,score:e}:e[s]>e[o]?{finished:!0,winner:s,score:e}:{finished:!0,tie:!0,score:e}}return{finished:!1,score:e}}class z{constructor(t="BaseAI"){$(this,"name");this.name=t}getLegalActions(t){return O(t)}applyMove(t,e){return v(t,e)}checkGameResult(t){return C(t.board,t.players)}async decidePlace(t){return await this.getBestPlace(t)}async decideMove(t){return await this.getBestMove(t)}}const T=[[1,0],[-1,0],[0,1],[0,-1]];class q extends z{constructor(e=2){super("MinimaxAI");$(this,"maxDepth");$(this,"startTime",0);$(this,"timeLimit",5e3);$(this,"zocCache",new Map);this.maxDepth=e}evaluate(e){const n=this.evaluateZOCDistance(e),r=this.evaluateTerritoryPotential(e);return 2*n+r}getBestPlace(e){const n=O(e);return n[Math.floor(Math.random()*n.length)]}getBestMove(e){this.startTime=performance.now();const n=e.turn==="R",r=this.getClaimedTerritoryPositions(e,e.turn);let o=-1/0,s=[];for(let i=1;i<=this.maxDepth;i++){const l=O(e),y=l.filter(d=>d.type==="move"),a=y.filter(d=>{if(d.type==="move"){const x=`${d.from.x},${d.from.y}`;return!r.has(x)}return!0}),u=a.length>0?a:y.length>0?y:l;if(performance.now()-this.startTime>this.timeLimit)break;let f=n?-1/0:1/0,g=[];const p=d=>n?d>f:d<f;for(const d of u){if(performance.now()-this.startTime>this.timeLimit)break;const x=v(M(e),d),m=this.minimax(x,i-1,!n,-1/0,1/0);!isFinite(m)||isNaN(m)||(p(m)?(f=m,g=[d]):m===f&&g.push(d))}f>o&&(o=f,s=g)}return b({legalActions:s})||s[0]}minimax(e,n,r,o=-1/0,s=1/0){if(this.checkGameResult(e).finished)return this.evaluate(e);if(n===0)return this.evaluate(e);const l=O(e);if(r){let y=-1/0;for(const a of l){const u=M(e);v(u,a);const f=this.minimax(u,n-1,!1,o,s);if(y=Math.max(y,f),o=Math.max(o,f),s<=o)break}return y}else{let y=1/0;for(const a of l){const u=M(e);v(u,a);const f=this.minimax(u,n-1,!0,o,s);if(y=Math.min(y,f),s=Math.min(s,f),s<=o)break}return y}}evaluateZOCDistance(e){const n=e.board.flatMap(i=>i.map(l=>`${l.stone}:${l.wallTop}:${l.wallLeft}`)).join(",");let r,o;if(this.zocCache.has(n)){const i=this.zocCache.get(n);r=i.redDist,o=i.blueDist}else{let i=function(u){const f=Array.from({length:7},()=>Array(7).fill(1/0)),g=[];for(const[p,d]of u)f[d][p]=0,g.push([p,d,0]);for(;g.length>0;){const[p,d,x]=g.shift();for(const[m,h]of T){const w=p+m,A=d+h;w<0||A<0||w>=7||A>=7||m===-1&&p>0&&l[d][p].wallLeft!==null||m===1&&p<6&&l[d][p+1].wallLeft!==null||h===-1&&d>0&&l[d][p].wallTop!==null||h===1&&d<6&&l[d+1][p].wallTop!==null||f[A][w]>x+1&&(f[A][w]=x+1,g.push([w,A,x+1]))}}return f};const l=e.board,y=[],a=[];for(let u=0;u<7;u++)for(let f=0;f<7;f++)l[u][f].stone==="R"&&y.push([f,u]),l[u][f].stone==="B"&&a.push([f,u]);if(y.length===0||a.length===0)return 0;r=i(y),o=i(a),this.zocCache.set(n,{redDist:r,blueDist:o})}let s=0;for(let i=0;i<7;i++)for(let l=0;l<7;l++){if(e.board[i][l].stone!==null)continue;const y=r[i][l],a=o[i][l];if(!isFinite(y)&&!isFinite(a))continue;const u=1/(y+1),f=1/(a+1);s+=u-f}return s}evaluateTerritoryPotential(e){const n=e.board,r=new Set;let o=0;for(let s=0;s<7;s++)for(let i=0;i<7;i++){const l=`${i},${s}`;if(r.has(l))continue;if(n[s][i].stone!==null){r.add(l);continue}const a=[{x:i,y:s}],u=[],f=new Set,g=new Set;for(;a.length>0;){const h=a.pop(),w=`${h.x},${h.y}`;if(!r.has(w)){r.add(w),u.push(h);for(const[A,D]of T){const S=h.x+A,I=h.y+D;if(S<0||I<0||S>=7||I>=7||R(n,h,{x:S,y:I}))continue;const Z=n[I][S];if(Z.stone===null){const G=`${S},${I}`;r.has(G)||a.push({x:S,y:I})}else f.add(Z.stone),g.add(`${S},${I}`)}}}if(f.size!==1)continue;const p=[...f][0],d=u.length,x=g.size,m=d-x*10;p==="R"?o+=m:o-=m}return o}getClaimedTerritoryPositions(e,n){const r=e.board,o=new Set,s=new Set;for(let i=0;i<7;i++)for(let l=0;l<7;l++){const y=`${l},${i}`;if(o.has(y))continue;if(r[i][l].stone!==null){o.add(y);continue}const u=[{x:l,y:i}],f=[],g=new Set;for(;u.length>0;){const p=u.pop(),d=`${p.x},${p.y}`;if(!o.has(d)){o.add(d),f.push(p);for(const[x,m]of T){const h=p.x+x,w=p.y+m;if(h<0||w<0||h>=7||w>=7||R(r,p,{x:h,y:w}))continue;const A=r[w][h];if(A.stone===null){const D=`${h},${w}`;o.has(D)||u.push({x:h,y:w})}else g.add(A.stone)}}}if(!(g.has("R")&&g.has("B"))&&g.size===1&&g.has(n))for(const p of f)s.add(`${p.x},${p.y}`)}return s}}function N(c,t=2){const e=new q(t);return e.startTime=performance.now(),e.timeLimit=3e3,e.getBestMove(c)}self.onmessage=c=>{var r;const{aiType:t,gameState:e}=c.data;let n=null;try{const o=O(e);if(e.phase==="finished"){self.postMessage({action:null,info:"Game finished, no action taken."});return}if(o.length===0){self.postMessage({error:"No legal actions available but game is not finished."});return}if(e.phase==="placing")switch(t){case"minimax":n=P(e,o);break;case"random":default:n=b({legalActions:o});break}else if(e.phase==="playing")switch(t){case"minimax":n=N(e,((r=c.data.config)==null?void 0:r.depth)??2);break;case"random":default:n=b({legalActions:o});break}else{self.postMessage({error:`Unexpected game phase: ${e.phase}`});return}n?self.postMessage({action:n}):self.postMessage({action:b({legalActions:o}),info:"Fell back to random action."})}catch(o){self.postMessage({error:o.message,stack:o.stack})}}})();
