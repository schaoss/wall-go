var _=Object.defineProperty;var N=(k,v,b)=>v in k?_(k,v,{enumerable:!0,configurable:!0,writable:!0,value:b}):k[v]=b;var $=(k,v,b)=>N(k,typeof v!="symbol"?v+"":v,b);(function(){"use strict";function v(l,t,e,s=2){const r=[[l,0]],n=new Set([`${l.x},${l.y}`]);for(;r.length;){const[{x:o,y:i},u]=r.shift();if(u>s)continue;if(o===t.x&&i===t.y&&u!==0)return!0;if(u===s)continue;[[1,0,"left"],[-1,0,"left"],[0,1,"top"],[0,-1,"top"]].forEach(([f,d,c])=>{const a=o+f,p=i+d;if(a<0||p<0||a>=7||p>=7||(c==="left"?f===1?e[i][o+1].wallLeft:e[i][o].wallLeft:d===1?e[i+1][o].wallTop:e[i][o].wallTop)||e[p][a].stone)return;const w=`${a},${p}`;n.has(w)||(n.add(w),r.push([{x:a,y:p},u+1]))})}return!1}function b(l,t,e){const s=[],r=l.length,n=["top","left","right","bottom"];for(const o of n){let i=!1;o==="top"&&e>0&&!l[e][t].wallTop&&(i=!0),o==="left"&&t>0&&!l[e][t].wallLeft&&(i=!0),o==="right"&&t<r-1&&!l[e][t+1].wallLeft&&(i=!0),o==="bottom"&&e<r-1&&!l[e+1][t].wallTop&&(i=!0),i&&s.push({type:"wall",from:{x:t,y:e},pos:{x:t,y:e},dir:o})}return s}function z(l){const t=l.length,e=Array.from({length:t},()=>Array(t).fill(!1)),s=Array.from({length:t},()=>Array(t).fill(null)),r=[[1,0,"left"],[-1,0,"left"],[0,1,"top"],[0,-1,"top"]];function n(o,i){const u=[{x:o,y:i}],y=[],f=new Set;for(e[i][o]=!0;u.length;){const{x:d,y:c}=u.shift();y.push({x:d,y:c});const a=l[c][d];a.stone&&f.add(a.stone),r.forEach(([p,g,w])=>{const m=d+p,h=c+g;m<0||h<0||m>=t||h>=t||(w==="left"?p===1?l[c][d+1].wallLeft:a.wallLeft:g===1?l[h][m].wallTop:a.wallTop)||e[h][m]||(e[h][m]=!0,u.push({x:m,y:h}))})}if(f.size===1){const d=f.values().next().value;y.forEach(({x:c,y:a})=>{s[a][c]=d})}}for(let o=0;o<t;o++)for(let i=0;i<t;i++)e[o][i]||n(i,o);return s}function B({legalActions:l}){return l.length===0?null:l[Math.floor(Math.random()*l.length)]}function D(l,t){const{board:e}=l,s=[];for(let r=0;r<e.length;r++)for(let n=0;n<e.length;n++)v(t,{x:n,y:r},e)&&s.push({x:n,y:r});return s}function S(l){const{board:t,turn:e,phase:s}=l,r=[];if(s==="placing")for(let n=0;n<t.length;n++)for(let o=0;o<t.length;o++)t[n][o].stone||r.push({type:"place",pos:{x:o,y:n}});else if(s==="playing")for(let n=0;n<t.length;n++)for(let o=0;o<t.length;o++)t[n][o].stone===e&&(D(l,{x:o,y:n}).forEach(i=>{for(const u of b(t,i.x,i.y))r.push({type:"move",from:{x:o,y:n},pos:{x:i.x,y:i.y},followUp:u})}),r.push(...b(t,o,n)));return r}function I(l){return JSON.parse(JSON.stringify(l))}function T(l,t){const e=I(l),{board:s,turn:r}=e;if(t.type==="place")s[t.pos.y][t.pos.x].stone=r;else if(t.type==="move"&&t.from){if(s[t.from.y][t.from.x].stone=null,s[t.pos.y][t.pos.x].stone=r,t.followUp)return T(e,t.followUp)}else t.type==="wall"&&t.dir&&(t.dir==="top"&&(s[t.pos.y][t.pos.x].wallTop=r),t.dir==="left"&&(s[t.pos.y][t.pos.x].wallLeft=r),t.dir==="right"&&(s[t.pos.y][t.pos.x+1].wallLeft=r),t.dir==="bottom"&&(s[t.pos.y+1][t.pos.x].wallTop=r));return e.turn=r==="R"?"B":"R",e}function G(l,t,e){const s=T(l,t),r=S(s);for(const n of r)if(n.type==="move"&&n.from&&s.board[n.from.y][n.from.x].stone===e)return!0;return!1}function O(l,t){const e=t.filter(u=>u.type==="place");if(e.length===1)return e[0];const s=l.board.length;function r(u,y){var g,w;const{board:f}=u,d=[];for(let m=0;m<s;m++)for(let h=0;h<s;h++)f[m][h].stone===y&&d.push({x:h,y:m});const c=Array.from({length:s},()=>Array(s).fill(!1)),a=[...d];let p=0;for(;a.length;){const{x:m,y:h}=a.shift();if(c[h][m])continue;c[h][m]=!0,p++;const x=[{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];for(const{dx:L,dy:R}of x){const M=m+L,A=h+R;M>=0&&M<s&&A>=0&&A<s&&!c[A][M]&&!f[A][M].stone&&(L===1&&!f[h][m+1].wallLeft||L===-1&&!f[h][m].wallLeft||R===1&&!((w=(g=f[h+1])==null?void 0:g[m])!=null&&w.wallTop)||R===-1&&!f[h][m].wallTop)&&a.push({x:M,y:A})}}return p}function n(u){const{x:y,y:f}=u;return(y===0||y===s-1)&&(f===0||f===s-1)?-3:y===0||y===s-1||f===0||f===s-1?-2:0}let o=-1/0,i=[];for(const u of e){const y=T(l,u),f=r(y,l.turn)+n(u.pos);f>o?(o=f,i=[u]):f===o&&i.push(u)}return B({legalActions:i})}function P(l,t){const e=Object.fromEntries(t.map(n=>[n,0])),s=new Set;if(l.forEach((n,o)=>n.forEach((i,u)=>{i.stone&&s.add(`${u},${o}`)})),s.size===0)return{finished:!1,score:e};const r=z(l);for(let n=0;n<l.length;n++)for(let o=0;o<l.length;o++){const i=r[n][o];i&&(e[i]++,s.delete(`${o},${n}`))}if(s.size===0){const[n,o]=t;return e[n]>e[o]?{finished:!0,winner:n,score:e}:e[o]>e[n]?{finished:!0,winner:o,score:e}:{finished:!0,tie:!0,score:e}}return{finished:!1,score:e}}class q{constructor(t="BaseAI"){$(this,"name");this.name=t}getLegalActions(t){return S(t)}applyMove(t,e){return T(t,e)}checkGameResult(t){return P(t.board,t.players)}async decidePlace(t){return await this.getBestPlace(t)}async decideMove(t){return await this.getBestMove(t)}}class C extends q{constructor(e=2){super("MinimaxAI");$(this,"maxDepth");$(this,"startTime",0);$(this,"timeLimit",5e3);this.maxDepth=e}evaluate(e){const s=new Set(Array.from(e.board.flatMap((i,u)=>i.map((y,f)=>y.stone===e.turn?`${f},${u}`:null))).filter(Boolean)),r=e.turn==="R"?"B":"R",n=this.evaluateTerritory(e,e.turn),o=this.evaluateTerritory(e,r);return 3*s.size-3*this.evaluateReachable(e,r)+5*n-4*o}evaluateReachable(e,s){const r=new Set;for(let n=0;n<e.board.length;n++)for(let o=0;o<e.board[0].length;o++)e.board[n][o].stone===s&&r.add(`${o},${n}`);return r.size}getBestPlace(e){const s=S(e).filter(r=>r.type==="place");return s[Math.floor(Math.random()*s.length)]}getBestMove(e){var i,u;this.startTime=performance.now();const r=((i=this.checkGameResult(e).score)==null?void 0:i[e.turn])??0;let n=-1/0,o=[];for(let y=1;y<=this.maxDepth;y++){const f=S(e).filter(p=>p.type!=="place"&&!G(e,p,e.turn)),d=f.length>0?f:S(e);if(performance.now()-this.startTime>this.timeLimit)break;let c=-1/0,a=[];for(const p of d){if(performance.now()-this.startTime>this.timeLimit)break;const g=T(I(e),p);if((((u=this.checkGameResult(g).score)==null?void 0:u[e.turn])??0)<r)continue;const h=this.minimax(g,y-1,!1,e.turn,-1/0,1/0);h>c?(c=h,a=[p]):h===c&&a.push(p)}c>n&&(n=c,o=a)}return o[Math.floor(Math.random()*o.length)]}minimax(e,s,r,n,o=-1/0,i=1/0){if(performance.now()-this.startTime>this.timeLimit)return this.evaluate(e);const u=this.checkGameResult(e);if(s===0||u.finished)return this.evaluate(e);const y=S(e).filter(f=>f.type!=="place");if(r){let f=-1/0;for(const d of y){const c=this.minimax(T(I(e),d),s-1,!1,n,o,i);if(f=Math.max(f,c),o=Math.max(o,c),i<=o)break}return f}else{let f=1/0;for(const d of y){const c=this.minimax(T(I(e),d),s-1,!0,n,o,i);if(f=Math.min(f,c),i=Math.min(i,c),i<=o)break}return f}}evaluateTerritory(e,s){const r=new Set,n=e.board,o=n.length,i=n[0].length;let u=0;const y=(c,a,p,g)=>p===-1&&c>0?n[a][c].wallLeft!==null:p===1&&c<i-1?n[a][c+1].wallLeft!==null:g===-1&&a>0?n[a][c].wallTop!==null:g===1&&a<o-1?n[a+1][c].wallTop!==null:!1,f=[[1,0],[-1,0],[0,1],[0,-1]],d=(c,a)=>{const p=[[c,a]],g=[];let w=!1;const m=new Set;for(;p.length>0;){const[h,x]=p.pop(),L=`${h},${x}`;if(!r.has(L)){r.add(L),g.push([h,x]),(h===0||x===0||h===i-1||x===o-1)&&(w=!0),m.add(n[x][h].stone);for(const[R,M]of f){const A=h+R,E=x+M;if(A<0||E<0||A>=i||E>=o||y(h,x,R,M))continue;const Z=`${A},${E}`;r.has(Z)||p.push([A,E])}}}return!w&&m.size===1&&m.has(s)?g.length:0};for(let c=0;c<o;c++)for(let a=0;a<i;a++){const p=`${a},${c}`;r.has(p)||(u+=d(a,c))}return u}}function U(l,t=2){const e=new C(t);return e.startTime=performance.now(),e.timeLimit=3e3,e.getBestMove(l)}self.onmessage=l=>{var r;const{aiType:t,gameState:e}=l.data;let s=null;try{const n=S(e);if(e.phase==="finished"){self.postMessage({action:null,info:"Game finished, no action taken."});return}if(n.length===0){self.postMessage({error:"No legal actions available but game is not finished."});return}if(e.phase==="placing")switch(t){case"minimax":s=O(e,n);break;case"random":default:s=B({legalActions:n});break}else if(e.phase==="playing")switch(t){case"minimax":s=U(e,((r=l.data.config)==null?void 0:r.depth)??2);break;case"random":default:s=B({legalActions:n});break}else{self.postMessage({error:`Unexpected game phase: ${e.phase}`});return}s?self.postMessage({action:s}):self.postMessage({action:B({legalActions:n}),info:"Fell back to random action."})}catch(n){self.postMessage({error:n.message,stack:n.stack})}}})();
