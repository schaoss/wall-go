var Y=Object.defineProperty;var Q=(A,R,S)=>R in A?Y(A,R,{enumerable:!0,configurable:!0,writable:!0,value:S}):A[R]=S;var B=(A,R,S)=>Q(A,typeof R!="symbol"?R+"":R,S);(function(){"use strict";const R=["R","B"];function S(c,e,t,o=2){const s=[[c,0]],n=new Set([`${c.x},${c.y}`]);for(;s.length;){const[{x:i,y:r},a]=s.shift();if(a>o)continue;if(i===e.x&&r===e.y&&a!==0)return!0;if(a===o)continue;[[1,0,"left"],[-1,0,"left"],[0,1,"top"],[0,-1,"top"]].forEach(([f,u,p])=>{const h=i+f,d=r+u;if(k(h,d)||(p==="left"?f===1?t[r][i+1].wallLeft:t[r][i].wallLeft:u===1?t[r+1][i].wallTop:t[r][i].wallTop)||t[d][h].stone)return;const y=`${h},${d}`;n.has(y)||(n.add(y),s.push([{x:h,y:d},a+1]))})}return!1}function k(c,e){return c<0||e<0||c>=7||e>=7}const M=[[1,0,"left"],[-1,0,"left"],[0,1,"top"],[0,-1,"top"]],L=["right","left","bottom","top"];function T(c,e,t){const o=t.x-e.x,s=t.y-e.y;for(const[n,i,r]of M)if(o===n&&s===i)return(n===1||i===1?c[t.y][t.x]:c[e.y][e.x])[r==="left"?"wallLeft":"wallTop"]!==null;return!1}function C(c,e,t){const o=[],s=c.length;for(let n=0;n<M.length;n++){const[i,r,a]=M[n],l=e+i,f=t+r;if(l<0||l>=s||f<0||f>=s)continue;if(!(i===1||r===1?c[f][l]:c[t][e])[a==="left"?"wallLeft":"wallTop"]){const p=L[n];o.push({type:"wall",from:{x:e,y:t},pos:{x:e,y:t},dir:p})}}return o}function b(c=[]){return c.length===0?null:c[Math.floor(Math.random()*c.length)]}function N(c,e){const{board:t}=c,o=[];for(let s=0;s<t.length;s++)for(let n=0;n<t.length;n++)S(e,{x:n,y:s},t)&&o.push({x:n,y:s});return o}function E(c){const{board:e,turn:t,phase:o}=c,s=[];if(o==="placing")for(let n=0;n<e.length;n++)for(let i=0;i<e.length;i++)e[n][i].stone||s.push({type:"place",pos:{x:i,y:n}});else if(o==="playing")for(let n=0;n<e.length;n++)for(let i=0;i<e.length;i++)e[n][i].stone===t&&(N(c,{x:i,y:n}).forEach(r=>{for(const a of C(e,r.x,r.y))s.push({type:"move",from:{x:i,y:n},pos:{x:r.x,y:r.y},followUp:a})}),s.push(...C(e,i,n)));return s}function F(c,e,t,o){const s=o==="R"?"B":"R",n=3-Math.max(Math.abs(e-3),Math.abs(t-3));let i=0,r=0;c.forEach((f,u)=>f.forEach((p,h)=>{p.stone===o?(h===e&&Math.abs(u-t)<=2||u===t&&Math.abs(h-e)<=2)&&(i=2):p.stone===s&&(h===e&&Math.abs(u-t)<=2||u===t&&Math.abs(h-e)<=2)&&(r=2)}));const a=-(+(e===0||e===6)+ +(t===0||t===6));let l=0;return c.forEach((f,u)=>f.forEach((p,h)=>{if(p.stone===s){const d=Math.min(h+u,h+6-u,6-h+u,12-h-u);l+=Math.max(0,2-d)}})),l=Math.min(2,l),3*n+4*i+2*r+1*l+1*a}function K(c){const{board:e,turn:t}=c;let o=-1/0;const s=[];for(let i=0;i<7;i++)for(let r=0;r<7;r++){if(e[i][r].stone)continue;const a=F(e,r,i,t);a>o?(o=a,s.length=0,s.push({x:r,y:i})):a===o&&s.push({x:r,y:i})}return{type:"place",pos:s[Math.floor(Math.random()*s.length)]}}function G(c){return JSON.parse(JSON.stringify(c))}function v(c,e){const t=G(c),{board:o,turn:s}=t;if(e.type==="place")o[e.pos.y][e.pos.x].stone=s;else if(e.type==="move"&&e.from){if(o[e.from.y][e.from.x].stone=null,o[e.pos.y][e.pos.x].stone=s,e.followUp)return v(t,e.followUp)}else e.type==="wall"&&e.dir&&(e.dir==="top"&&(o[e.pos.y][e.pos.x].wallTop=s),e.dir==="left"&&(o[e.pos.y][e.pos.x].wallLeft=s),e.dir==="right"&&(o[e.pos.y][e.pos.x+1].wallLeft=s),e.dir==="bottom"&&(o[e.pos.y+1][e.pos.x].wallTop=s));return t.turn=s==="R"?"B":"R",t}function P(c){const e=c.length,t=new Set,o=[];for(let s=0;s<e;s++)for(let n=0;n<e;n++){const i=O({x:n,y:s});if(t.has(i))continue;const r=[{x:n,y:s}],a=[],l=new Set;for(;r.length>0;){const u=r.pop(),p=O(u);if(t.has(p))continue;t.add(p),a.push(u);const h=c[u.y][u.x].stone;h!==null&&l.add(h);for(const[d,g]of M){const y=u.x+d,m=u.y+g;if(y<0||m<0||y>=e||m>=e||T(c,u,{x:y,y:m}))continue;const w=O({x:y,y:m});t.has(w)||r.push({x:y,y:m})}}const f=R.reduce((u,p)=>({...u,[p]:0}),{});for(const u of a){const p=c[u.y][u.x].stone;p!==null&&f[p]++}o.push({cells:a,borderingCounts:f})}return o}function O(c){return`${c.x},${c.y}`}function Z(c){const e=c.length,t=Array.from({length:e},()=>Array(e).fill(null));return P(c).forEach(({borderingCounts:s,cells:n})=>{if((s.R>0?1:0)+(s.B>0?1:0)===1){const r=s.R>0?"R":"B";n.forEach(({x:a,y:l})=>{t[l][a]=r})}}),t}function U(c,e){const t=Object.fromEntries(e.map(n=>[n,0])),o=new Set;if(c.forEach((n,i)=>n.forEach((r,a)=>{r.stone&&o.add(`${a},${i}`)})),o.size===0)return{finished:!1,score:t};const s=Z(c);for(let n=0;n<c.length;n++)for(let i=0;i<c.length;i++){const r=s[n][i];r&&(t[r]++,o.delete(`${i},${n}`))}if(o.size===0){const[n,i]=e;return t[n]>t[i]?{finished:!0,winner:n,score:t}:t[i]>t[n]?{finished:!0,winner:i,score:t}:{finished:!0,tie:!0,score:t}}return{finished:!1,score:t}}class q{constructor(e="BaseAI"){B(this,"name");this.name=e}getLegalActions(e){return E(e)}applyMove(e,t){return v(e,t)}checkGameResult(e){return U(e.board,e.players)}async decidePlace(e){return await this.getBestPlace(e)}async decideMove(e){return await this.getBestMove(e)}}function _(c){const e=[];for(let t=0;t<7;t++)for(let o=0;o<7;o++)c[t][o].stone&&e.push({player:c[t][o].stone,position:{x:o,y:t}});return e}class z extends q{constructor(t=2){super(`MinimaxAI - D${t}`);B(this,"maxDepth");B(this,"startTime",0);B(this,"timeLimit",5e3);B(this,"zocCache",new Map);B(this,"tt",new Map);this.maxDepth=t}evaluate(t){const o=this.evaluateZOCDistance(t),s=this.evaluateTerritoryPotential(t);return 1.5*o+s}getBestPlace(t){const o=E(t),s=t.turn==="R",n=this.findBestAction(t,o,s,()=>this.evaluateZOCDistance.bind(this));return b(n.actions)}getBestMove(t){this.startTime=performance.now();const o=t.turn==="R",s=this.getClaimedTerritoryPositions(t,t.turn),n=E(t),i=n.filter(f=>!s.has(O(f.from))),r=i.length>0?i:n;r.sort((f,u)=>this.actionHeuristic(u,t)-this.actionHeuristic(f,t));let a=-1/0,l=[];for(let f=1;f<=this.maxDepth;f++){const u=d=>g=>performance.now()-this.startTime>this.timeLimit?a:this.minimax(g,f-1,d),{actions:p,score:h}=this.findBestAction(t,r,o,u);!isFinite(h)||isNaN(h)||h>a&&(a=h,l=p)}return l.length||(l=r),b(l)}findBestAction(t,o,s,n){const i=s?-1/0:1/0,r={actions:[],score:i},a=(l,f)=>s?l>f:l<f;for(const l of o){const f=n(!s)(v(t,l));!isFinite(f)||isNaN(f)||(a(f,r.score)?(r.score=f,r.actions.length=0,r.actions.push(l)):f===r.score&&r.actions.push(l))}return r.actions.length>0?r:{actions:o,score:i}}minimax(t,o,s,n=-1/0,i=1/0){const r=J(t,o,s);if(this.tt.has(r))return this.tt.get(r);if(o===0)return this.evaluate(t);if(this.checkGameResult(t).finished)return this.evaluate(t);const l={max:{defaultValue:-1/0,isBetterResult:h=>h>n,updateFunction:h=>n=Math.max(n,h)},min:{defaultValue:1/0,isBetterResult:h=>h<i,updateFunction:h=>i=Math.min(i,h)}},f=s?l.max:l.min;let u=f.defaultValue;const p=E(t);for(const h of p){const d=this.minimax(v(t,h),o-1,!s,n,i);if(f.isBetterResult(d)&&(u=d,f.updateFunction(d)),n>=i)break}return this.tt.set(r,u),u}evaluateZOCDistance(t,o=_(t.board)){const s=$(t);let n,i;if(this.zocCache.has(s)){const a=this.zocCache.get(s);n=a.redDist,i=a.blueDist}else{let a=function(p){const h=Array.from({length:7},()=>Array(7).fill(1/0)),d=[];for(const{x:g,y}of p)h[y][g]=0,d.push([g,y,0]);for(;d.length>0;){const[g,y,m]=d.shift();for(const[w,I]of M){const x=g+w,D=y+I;k(x,D)||T(l,{x:g,y},{x,y:D})||h[D][x]>m+1&&(h[D][x]=m+1,d.push([x,D,m+1]))}}return h};const l=t.board,f=o.filter(p=>p.player==="R").map(p=>p.position),u=o.filter(p=>p.player==="B").map(p=>p.position);for(let p=0;p<7;p++)for(let h=0;h<7;h++)l[p][h].stone==="R"&&f.push({x:h,y:p}),l[p][h].stone==="B"&&u.push({x:h,y:p});if(f.length===0||u.length===0)return 0;n=a(f),i=a(u),this.zocCache.set(s,{redDist:n,blueDist:i})}let r=0;for(let a=0;a<7;a++)for(let l=0;l<7;l++){const f=n[a][l],u=i[a][l];if(!isFinite(f)&&!isFinite(u))continue;const p=1/(f+1),h=1/(u+1),g=t.board[a][l].stone!==null?.2:1;r+=g*(p-h)}return r}evaluateTerritoryPotential(t){const o=t.board,s=Z(o),n={R:0,B:0};for(let l=0;l<o.length;l++)for(let f=0;f<o.length;f++){const u=s[l][f];u&&n[u]++}const i=n.R-n.B;if(i!==0)return i;const r=new Set,a={R:0,B:0};for(let l=0;l<o.length;l++)for(let f=0;f<o.length;f++){const u=s[l][f],p=`${f},${l}`;if(!u||r.has(p))continue;let h=0;const d=[{x:f,y:l}];for(r.add(p);d.length>0;){const g=d.pop();h++;for(const[y,m]of M){const w=g.x+y,I=g.y+m;if(k(w,I)||s[I][w]!==u)continue;const x=`${w},${I}`;r.has(x)||(r.add(x),d.push({x:w,y:I}))}}a[u]=Math.max(a[u],h)}return a.R-a.B}actionHeuristic(t,o){if(t.type!=="move")return 0;const s=o.turn==="R"?"B":"R",n=_(o.board).filter(r=>r.player===s);let i=1/0;for(const r of n){const a=Math.abs(r.position.x-t.pos.x)+Math.abs(r.position.y-t.pos.y);a<i&&(i=a)}return-i}getClaimedTerritoryPositions(t,o){const s=t.board,n=new Set,i=P(s);for(const{borderingCounts:r,cells:a}of i)if(Object.values(r).reduce((l,f)=>l+f)===r[o])for(const l of a)n.add(`${l.x},${l.y}`);return n}}function H(){return Math.floor(Math.random()*4294967296)>>>0}function V(c){const e=c.stone==="R"?1:c.stone==="B"?2:0;let t=0;return c.wallLeft&&(t|=1),c.wallTop&&(t|=2),e*4+t}const j=Array.from({length:7},()=>Array.from({length:7},()=>Array.from({length:12},()=>H())));function $(c){let e=0;for(let t=0;t<7;t++)for(let o=0;o<7;o++){const s=V(c.board[t][o]);e^=j[t][o][s]}return e>>>0}function J(c,e,t){return($(c)^e<<1>>>0^(t?1:0))>>>0}function W(c,e=2){const t=new z(e);return t.startTime=performance.now(),t.timeLimit=3e3,t.getBestMove(c)}self.onmessage=c=>{var s;const{aiType:e,gameState:t}=c.data;let o=null;try{const n=E(t);if(t.phase==="finished"){self.postMessage({action:null,info:"Game finished, no action taken."});return}if(n.length===0){self.postMessage({error:"No legal actions available but game is not finished."});return}if(t.phase==="placing")switch(e){case"minimax":o=K(t);break;case"random":default:o=b(n);break}else if(t.phase==="playing")switch(e){case"minimax":o=W(t,((s=c.data.config)==null?void 0:s.depth)??2);break;case"random":default:o=b(n);break}else{self.postMessage({error:`Unexpected game phase: ${t.phase}`});return}o?self.postMessage({action:o}):self.postMessage({action:b(n),info:"Fell back to random action."})}catch(n){self.postMessage({error:n.message,stack:n.stack})}}})();
